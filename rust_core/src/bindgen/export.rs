use super::*;
use std::fs::{self};
use std::path::Path;
use ts_rs::TS;

// ğŸ”¥ æ–°å¢ï¼šAndroid Java å¸¸é‡è¾“å‡ºè·¯å¾„

pub fn export_ts_types(path_str: &str) {
    println!("ğŸ“¦ Exporting TypeScript bindings...");

    MacroConfig::export().expect("Failed to export MacroConfig TS bindings");

    // 1. æ”¶é›†æ‰€æœ‰éœ€è¦å¯¼å‡ºçš„ç±»å‹å®šä¹‰
    // Struct::decl() ä¼šè¿”å›è¯¥ç»“æ„ä½“çš„ TypeScript å®šä¹‰å­—ç¬¦ä¸²
    let mut ts_content = String::from("// This file is auto-generated by Rust. Do not edit.\n\n");
    ts_content.push_str("export ");
    ts_content.push_str(&Action::decl());
    ts_content.push('\n');

    ts_content.push_str("export ");
    ts_content.push_str(&MacroConfig::decl());
    ts_content.push('\n');

    // å¦‚æœä½ æœ‰æ›´å¤šç»“æ„ä½“ï¼Œç»§ç»­ push...
    // ts_content.push_str(&AnotherStruct::decl());

    // 2. å†™å…¥æ–‡ä»¶
    let path = Path::new(TS_OUTPUT_PATH);

    // ç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).unwrap();
    }

    fs::write(path, ts_content).expect("Failed to write TypeScript definitions");

    println!("âœ… TypeScript types exported to: {}", TS_OUTPUT_PATH);
}
