use super::*;
use std::fs::{self};
use std::path::Path;
use ts_rs::TS;

// ğŸ”¥ åœ¨è¿™é‡Œå®šä¹‰å¸¸é‡ï¼Œæƒ³æ€ä¹ˆæ”¹å°±æ€ä¹ˆæ”¹
const TS_OUTPUT_PATH: &str = "../script_template/src/types/touch-helper.d.ts";

#[test]
fn export_all_types() {
    // 1. æ”¶é›†æ‰€æœ‰éœ€è¦å¯¼å‡ºçš„ç±»å‹å®šä¹‰
    // Struct::decl() ä¼šè¿”å›è¯¥ç»“æ„ä½“çš„ TypeScript å®šä¹‰å­—ç¬¦ä¸²
    let mut ts_content = String::from("// This file is auto-generated by Rust. Do not edit.\n\n");
    ts_content.push_str("export ");
    ts_content.push_str(&Action::decl());
    ts_content.push('\n');

    ts_content.push_str("export ");
    ts_content.push_str(&MacroConfig::decl());
    ts_content.push('\n');

    // å¦‚æœä½ æœ‰æ›´å¤šç»“æ„ä½“ï¼Œç»§ç»­ push...
    // ts_content.push_str(&AnotherStruct::decl());

    // 2. å†™å…¥æ–‡ä»¶
    let path = Path::new(TS_OUTPUT_PATH);

    // ç¡®ä¿çˆ¶ç›®å½•å­˜åœ¨
    if let Some(parent) = path.parent() {
        fs::create_dir_all(parent).unwrap();
    }

    fs::write(path, ts_content).expect("Failed to write TypeScript definitions");

    println!("âœ… TypeScript types exported to: {}", TS_OUTPUT_PATH);
}
